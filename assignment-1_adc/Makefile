#####################################################################
##
## Author: scct (https://github.com/neaerae)
## cschaefer.itsb-b2018@fh-salzburg.ac.at
##
## version 1.2
##
## compile: 					$ make
## sync to rpi:					$ make sync
## run:							$ make test
## run w/ debug information: 	$ make debug
##
## To be done:
## - Emulate on x86 with QEMU on host
##
## make sure your remote user $(PI_USER) is in the gpio group to access the ios:
## $ sudo adduser pi gpio
#####################################################################

PROJ_NAME 	:= assignment-1_adc

# set directories
OBJ_DIR 	:= build/obj
DEP_DIR 	:= build/dep
SOURCE_DIR  := source
BUILD_DIR 	:= build
PROJ_DIR	:= $(shell pwd)
DATA_DIR	:= data

# output binary
TARGET := $(BUILD_DIR)/test

# RPi network settings - key authentication required
PI_ADDR 	:= 192.168.1.100
PI_USER		:= scct
PI_DIR		:= /home/scct/eph
PI_PROJ_DIR	:= $(PI_DIR)/$(PROJ_NAME)
PI_REMOTEBIN:= $(PI_DIR)/$(PROJ_NAME)/$(TARGET)

# set compiler & linker
CC 	:= gcc
LD 	:= gcc

# find our source files (recursively)
SOURCE_FILES := $(wildcard $(SOURCE_DIR)/*.c) 

# files included in the tarball generated by 'make dist' (e.g. add LICENSE file)
DISTFILES := $(TARGET)

# filename of the tar archive generated by 'make dist'
DISTOUTPUT := $(TARGET).tar.gz

# object files, auto generated from source files
OBJ_FILES := $(patsubst %,$(OBJ_DIR)/%.o,$(basename $(SOURCE_FILES)))
# dependency files, auto generated from source files
DEP_FILES := $(patsubst %,$(DEP_DIR)/%.d,$(basename $(SOURCE_FILES)))

# compilers (at least gcc and clang) don't create the subdirectories automatically
$(shell mkdir -p $(dir $(OBJ_FILES)) >/dev/null)
$(shell mkdir -p $(dir $(DEP_FILES)) >/dev/null)

# compiler flags
# -g ... adds debug information to our executable file
# -Wall ... enable most warnings
# -L ... path to the library dir
# -l ... name of the library ot be included
# -pedantic ... learn how to code 
CFLAGS = -g -Wall -Wextra -std=c89 -pedantic

# linker flags
LDFLAGS := -lwiringPi -lrt -lpthread

# flags required for dependency generation; passed to compilers
DEPFLAGS = -MT $@ -MD -MP -MF $(DEP_DIR)/$*.Td

# compile C source files
COMPILE.c = $(CC) $(DEPFLAGS) $(CFLAGS) $(CPPFLAGS) -c -o $@

# link object files to binary
LINK.o = $(LD) $(LDFLAGS) $(LDLIBS) -o $@
# precompile step
PRECOMPILE =

# postcompile step
POSTCOMPILE = mv -f $(DEP_DIR)/$*.Td $(DEP_DIR)/$*.d

all: $(TARGET)

dist: $(DISTFILES)
	$(TAR) -cvzf $(DISTOUTPUT) $^

.PHONY: clean
clean:
	$(RM) -r $(OBJ_DIR) $(DEP_DIR)
	$(RM) -r $(DATA_DIR)/*

.PHONY: distclean
distclean: clean
	$(RM) $(TARGET) $(DISTOUTPUT)

.PHONY: debug
debug: 
	@echo running binary with debug information
	$(TARGET) 2>&1

.PHONY: test
test:
	@echo running binary:
	$(TARGET) 2>/dev/null

.PHONY: install
install:
	@echo no install tasks configured

.PHONY: sync
sync:
	@echo syncing local directory $(PROJ_DIR) to RPi $(PI_USER)@$(PI_ADDR):$(PI_DIR)
	$(shell rsync -a $(PROJ_DIR) $(PI_USER)@$(PI_ADDR):$(PI_DIR)/)

.PHONY: data
data:
	@echo syncing remote data folder to host 

.PHONY: rbuild
rbuild: 
	@echo building remotely on $(PI_ADDR)
	$(shell ssh $(PI_ADDR) 'cd $(PI_PROJ_DIR); make')

.PHONY: rtest
rtest:
	@echo executing remotely on $(PI_ADDR)
	@echo ssh $(PI_ADDR) '$(PI_REMOTEBIN) 2>/dev/null'
	#$(shell ssh $(PI_ADDR) '$(PI_REMOTEBIN) 2>/dev/null' )

.PHONY: uninstall
uninstall:
	@echo no uninstall tasks configured

.PHONY: check
check:
	@echo no tests configured

.PHONY: help
help:
	@echo available targets: all dist clean distclean test debug install uninstall check

$(TARGET): $(OBJ_FILES)
	$(LINK.o) $^

$(OBJ_DIR)/%.o: %.c
$(OBJ_DIR)/%.o: %.c $(DEP_DIR)/%.d
	$(PRECOMPILE)
	$(COMPILE.c) $<
	$(POSTCOMPILE)

.PRECIOUS = $(DEP_DIR)/%.d
$(DEP_DIR)/%.d: ;

-include $(DEP_FILES)